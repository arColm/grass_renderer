#version 460
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 16, local_size_y = 16) in;

#include "0_scene_data.glsl"

//todo jesus clean this up
layout (rgba16f, set=1,binding=0) uniform image2D finalDrawImage;
layout (set=1,binding=1) uniform sampler2D colorImage;
layout (set=1,binding=2) uniform sampler2D depthImage;
layout (set=1,binding=3) uniform sampler2D normalImage;
layout (set=1,binding=4) uniform sampler2D specularMapImage;
layout (set=1,binding=5) uniform sampler2D positionImage;

//push constants block
layout( push_constant ) uniform constants
{
	//data1.xyz = player pos
	vec4 data1;
	vec4 data2;
	vec4 data3;
	vec4 data4;
} PushConstants;

// based on https://theorangeduck.com/page/pure-depth-ssao
vec3 normal_from_depth(float depth, vec2 uv) {
  
  const vec2 offset1 = vec2(0.0,0.01);
  const vec2 offset2 = vec2(0.01,0.0);
  
  float depth1 = texture(depthImage, uv + offset1).r;
  float depth2 = texture(depthImage, uv + offset2).r;
  
  vec3 p1 = vec3(offset1, depth1 - depth);
  vec3 p2 = vec3(offset2, depth2 - depth);
  
  vec3 normal = cross(p1, p2);
  normal.z = -normal.z;
  
  return normalize(normal);
}

// screen space reflections
// based on https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
vec4 getReflectedColor(vec2 texCoord)
{	
	vec4 color = vec4(0);
	int maxSteps = 100;
	float maxDistance = 238;
	float resolution = 1.0;
	int steps = 28;
	float thickness = 0.2;

	ivec2 texSize = textureSize(colorImage,0).xy;
	vec4 uv = vec4(0);

	vec4 startPos = vec4(texture(positionImage,texCoord).xyz,1);///todo vector from camera to world position
	//vec4 startPos = vec4(imageLoad(positionImage,texelCoord).xyz,1);///todo vector from camera to world position
	startPos.z *= -1;

	vec3 normalizedStartPos = normalize(startPos.xyz);

	mat3 v = mat3(sceneData.view);
	//v[3] = vec4(0,0,0,1);
	//v[0].w = 0;
	//v[1].w = 0;
	//v[2].w = 0;
	mat3 normalMatrix = transpose(inverse(v));


	vec3 normal = normalize((normalMatrix * texture(normalImage,texCoord).xyz).xyz);//might have to normalize
	normal.z *= -1;
	//normal = normal_from_depth(texture(depthImage,vec2(texelCoord)/texSize).r,vec2(texelCoord)/texSize);
	vec3 pivot = normalize(reflect(normalizedStartPos,normal));
	vec4 nextPos = startPos;

	vec4 startView = vec4(startPos.xyz + (pivot * 0.0),1.0);
	vec4 endView = vec4(startPos.xyz + (pivot * maxDistance),1.0);
	if(endView.z<=0.1) endView = vec4(0);
	//return vec4(vec3(0.01*(endView.xyz-startView.xyz).y),1);
	//return vec4(startView.xy,0,1);

	//transform viewspace coords to screen space
	mat4 p = sceneData.proj;
	vec4 startFrag = p * startView;
	startFrag /= startFrag.w;
	startFrag.xy = startFrag.xy * vec2(-0.5,-0.5) + 0.5;
	startFrag.xy *= texSize;
	vec4 endFrag = p * endView;
	endFrag /= endFrag.w;
	endFrag.xy = endFrag.xy * vec2(-0.5,-0.5) + 0.5;
	//return texture(colorImage,clamp(vec2(endFrag.xy),0,1));
	endFrag.xy *= texSize;
	//return vec4((endFrag-startFrag).r,0,0,1);
	vec2 frag = startFrag.xy;

	float dX = endFrag.x - startFrag.x;
	float dY = endFrag.y - startFrag.y;
	float useX = abs(dX)>=abs(dY)? 1.0 : 0.0;
	float delta = mix(abs(dY),abs(dX),useX) * clamp(resolution,0.0,1.0);
	vec2 increment = vec2(dX,dY) / max(delta,0.001);

	float search0 = 0;
	float search1 = 0;

	int hit0 = 0;
	int hit1 = 0;

	float viewDistance = startView.z;
	float depth = thickness;
	float i = 0;
	for(i=0;i<int(delta) && i < maxSteps;i++)
	{
		frag += increment;
		uv.xy = frag / texSize;
		nextPos = vec4(texture(positionImage,uv.xy).xyz,1);// todo
		//nextPos = vec4(imageLoad(positionImage,ivec2(uv.xy)).xyz,1);// todo
		//nextPos.y *= -1;
		nextPos.z = -nextPos.z;
		//return vec4(nextPos.xyz,1);

		

		search1 = mix((frag.y-startFrag.y)/dY,(frag.x-startFrag.x)/dX,useX);
		search1 = clamp(search1,0.0,1.0);

		viewDistance = (startView.z * endView.z) / mix(endView.z,startView.z,search1);
		depth = viewDistance - nextPos.z;

		if(depth>0 && depth<thickness)
		{
			hit0 = 1;
			break;
		}
		else
		{
			search0 = search1;
		}
	}
	//return vec4(hit0,0,0,1);
	search1 = search0 + ((search1-search0)/2.0);

	steps *= hit0;

	for(i=0;i<steps && i < maxSteps;i++)
	{
		frag = mix(startFrag.xy,endFrag.xy,search1);
		uv.xy = frag / texSize;
		nextPos = vec4(texture(positionImage,uv.xy).xyz,1); //todo
		//nextPos = vec4(imageLoad(positionImage,ivec2(uv.xy)).xyz,1);// todo
		//nextPos.y *= -1;
		nextPos.z = -nextPos.z;

		viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);
		depth = viewDistance - nextPos.z;

		if(depth > 0 && depth < thickness)
		{
			hit1 = 1;
			search1 = search0 + ((search1-search0)/2);
		}
		else
		{
			float temp = search1;
			search1 = search1 + ((search1-search0)/2);
			search0 = temp;
		}
	}

	float visibility = hit1 * nextPos.w * startPos.w *
		(1-max(dot(-normalizedStartPos,pivot),0)) *
		(1-clamp(depth / thickness,0,1)) *
		(1-clamp(length(nextPos-startPos)/maxDistance,0,1)) *
		(uv.x < 0 || uv.x > 1 ? 0 : 1) * (uv.y < 0 || uv.y > 1 ? 0 :1);

	visibility = clamp(visibility,0,1);

	uv.zw = vec2(visibility);
	//return uv;
	
	if(visibility<0.5)
	{
		color = texture(colorImage,texCoord);
	}
	else 
	{
		//uv.y = 1-uv.y;
		color = texture(colorImage,uv.xy);
	}

	return color;
}

void main()
{
	vec2 size = textureSize(colorImage,0).xy;
	vec2 texCoord = ivec2(gl_GlobalInvocationID.xy) / size;
	ivec2 finalDrawSize = imageSize(finalDrawImage);

	if(texCoord.x < size.x && texCoord.y < size.y)
	{
		vec4 color = texture(colorImage, texCoord);
		float depth = texture(depthImage, vec2(texCoord)).r;
		vec4 normal = texture(normalImage, texCoord);
		vec4 specular = texture(specularMapImage,texCoord);

		vec4 finalColor = color;
		if(specular.r>0)
		{
			finalColor = getReflectedColor(texCoord);
		}

		imageStore(finalDrawImage, ivec2(texCoord*finalDrawSize), finalColor);
	}
}