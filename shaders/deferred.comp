#version 460
#extension GL_GOOGLE_include_directive : require

layout (local_size_x = 16, local_size_y = 16) in;

#include "0_scene_data.glsl"

//todo jesus clean this up
layout (rgba16f, set=1,binding=0) uniform image2D finalDrawImage;
layout (rgba16f, set=1,binding=1) uniform image2D colorImage;
layout (set=1,binding=2) uniform sampler2D depthImage;
layout (rgba16f, set=1,binding=3) uniform image2D normalImage;
layout (rgba16f, set=1,binding=4) uniform image2D specularMapImage;
layout (rgba16f, set=1,binding=5) uniform image2D positionImage;

//push constants block
layout( push_constant ) uniform constants
{
	//data1.xyz = player pos
	vec4 data1;
	vec4 data2;
	vec4 data3;
	vec4 data4;
} PushConstants;

// based on https://theorangeduck.com/page/pure-depth-ssao
vec3 normal_from_depth(float depth, vec2 uv) {
  
  const vec2 offset1 = vec2(0.0,0.01);
  const vec2 offset2 = vec2(0.01,0.0);
  
  float depth1 = texture(depthImage, uv + offset1).r;
  float depth2 = texture(depthImage, uv + offset2).r;
  
  vec3 p1 = vec3(offset1, depth1 - depth);
  vec3 p2 = vec3(offset2, depth2 - depth);
  
  vec3 normal = cross(p1, p2);
  normal.z = -normal.z;
  
  return normalize(normal);
}

// screen space reflections
// based on https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html
vec4 getReflectedColor(ivec2 texelCoord)
{
	vec4 color = vec4(0);
	int maxSteps = 30;
	float maxDistance = 8;
	float resolution = 0.3;
	int steps = 5;
	float thickness = 0.5;

	vec2 texSize = imageSize(colorImage);

	vec4 uv = vec4(0);

	//vec4 startPos = vec4(2*vec2(texelCoord-0.5*texSize)/texSize,imageLoad(depthImage,texelCoord).r,1);///todo vector from camera to world position
	vec4 startPos = vec4(imageLoad(positionImage,texelCoord).xyz,1);///todo vector from camera to world position
	vec3 normalizedStartPos = normalize(startPos.xyz);
	mat4 normalMatrix = transpose(inverse(sceneData.view));
	vec3 normal = normalize((normalMatrix * imageLoad(normalImage,texelCoord)).xyz);//might have to normalize
	//normal = normal_from_depth(imageLoad(depthImage,texelCoord).r,texelCoord);
	vec3 pivot = normalize(reflect(normalizedStartPos,normal));

	vec4 nextPos = startPos;

	vec4 startView = vec4(startPos.xyz + (pivot * 0.0),1.0);
	vec4 endView = vec4(startPos.xyz + (pivot * maxDistance),1.0);

	//transform viewspace coords to screen space
	vec4 startFrag = sceneData.proj * startView;
	startFrag.xyz /= startFrag.w;
	startFrag.xy = startFrag.xy * 0.5 + 0.5;
	startFrag.xy *= texSize;
	vec4 endFrag = sceneData.proj * endView;
	endFrag.xyz /= endFrag.w;
	endFrag.xy = endFrag.xy * 0.5 + 0.5;
	endFrag.xy *= texSize;
	//return endFrag;
	vec2 frag = startFrag.xy;
	uv.xy = frag/texSize;

	float dX = endFrag.x - startFrag.x;
	float dY = endFrag.y - startFrag.y;
	float useX = abs(dX)>=abs(dY)? 1.0 : 0.0;
	float delta = mix(abs(dY),abs(dX),useX) * clamp(resolution,0.0,1.0);
	vec2 increment = vec2(dX,dY) / max(delta,0.001);

	float search0 = 0;
	float search1 = 0;

	int hit0 = 0;
	int hit1 = 0;

	float viewDistance = startView.z;
	float depth = thickness;
	float i = 0;
	for(i=0;i<int(delta) && i < maxSteps;i++)
	{
		frag += increment;
		uv.xy = frag/texSize;
		//nextPos = vec4(uv.xy,imageLoad(depthImage,ivec2(uv.xy)).r,1);// todo
		nextPos = vec4(imageLoad(positionImage,ivec2(uv.xy*texSize)).xyz,1);// todo


		search1 = mix((frag.y-startFrag.y)/dY,(frag.x-startFrag.x)/dX,useX);
		search1 = clamp(search1,0.0,1.0);

		viewDistance = (startView.y * endView.y) / mix(endView.y,startView.y,search1);
		depth = viewDistance - nextPos.y;

		if(depth>0 && depth<thickness)
		{
			hit0 = 1;
			break;
		}
		else
		{
			search0 = search1;
		}
	}
	
	search1 = search0 + ((search1-search0)/2.0);

	steps *= hit0;

	for(i=0;i<steps && i < maxSteps;i++)
	{
		frag = mix(startFrag.xy,endFrag.xy,search1);
		uv.xy = frag/texSize;
		//nextPos = vec4(uv.xy,imageLoad(depthImage,ivec2(uv.xy)).r,1); //todo
		nextPos = vec4(imageLoad(positionImage,ivec2(uv.xy*texSize)).xyz,1);// todo

		viewDistance = (startView.y * endView.y) / mix(endView.y, startView.y, search1);
		depth = viewDistance - nextPos.y;

		if(depth > 0 && depth < thickness)
		{
			hit1 = 1;
			search1 = search0 + ((search1-search0)/2);
		}
		else
		{
			float temp = search1;
			search1 = search1 + ((search1-search0)/2);
			search0 = temp;
		}
	}

	float visibility = hit1 * nextPos.w * 
		(1-max(dot(-normalizedStartPos,pivot),0)) *
		(1-clamp(depth / thickness,0,1)) *
		(1-clamp(length(nextPos-startPos)/maxDistance,0,1)) *
		(uv.x < 0 || uv.x > 1 ? 0 : 1) * (uv.y < 0 || uv.y > 1 ? 0 :1);

	visibility = clamp(visibility,0,1);

	uv.zw = vec2(visibility);
	//return uv;
	
	if(visibility==0)
	{
		color = imageLoad(colorImage,ivec2(texelCoord));
	}
	else 
	{
		uv.y = 1.0-uv.y;
		color = imageLoad(colorImage,ivec2(uv.xy*texSize));
	}

	return color;
}
void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(finalDrawImage);

	if(texelCoord.x < size.x && texelCoord.y < size.y)
	{
		vec4 color = imageLoad(colorImage, texelCoord);
		float depth = texture(depthImage, vec2(texelCoord)/size).r;
		vec4 normal = imageLoad(normalImage, texelCoord);
		vec4 specular = imageLoad(specularMapImage,texelCoord);

		vec4 finalColor = color;
		if(specular.r>0)
		{
			finalColor = getReflectedColor(texelCoord);
		}

		imageStore(finalDrawImage, texelCoord, finalColor);
	}
}